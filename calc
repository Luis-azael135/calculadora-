import math
import statistics
from collections import Counter

def validar_numero(mensaje, tipo="float", positivo=False, no_cero=False):
    """Valida entradas num√©ricas con manejo de excepciones y restricciones."""
    while True:
        try:
            entrada = input(mensaje).strip()
            if tipo == "float":
                valor = float(entrada)
            elif tipo == "int":
                valor = int(entrada)
            
            if positivo and valor < 0:
                print("‚ùå Error: El valor debe ser positivo.")
                continue
            if no_cero and valor == 0:
                print("‚ùå Error: No se permite divisi√≥n por cero.")
                continue
            return valor
        except ValueError:
            print(f"‚ùå Error: '{entrada}' no es un n√∫mero v√°lido. Intente nuevamente.")

def operaciones_basicas():
    """Ejecuta operaciones aritm√©ticas b√°sicas con validaci√≥n robusta."""
    print("\n" + "="*40)
    print("‡πÇ‡∏õ‡∏£‡πÅ‡∏Å‡∏£‡∏ö OPERACIONES B√ÅSICAS")
    print("="*40)
    
    a = validar_numero("Ingrese el primer n√∫mero: ", "float")
    b = validar_numero("Ingrese el segundo n√∫mero: ", "float")
    
    print("\nOperaciones disponibles:")
    print("1. Suma (+)")
    print("2. Resta (-)")
    print("3. Multiplicaci√≥n (*)")
    print("4. Divisi√≥n (/)")
    
    opcion = input("Seleccione una operaci√≥n (1-4): ").strip()
    
    try:
        if opcion == "1":
            resultado = a + b
            operador = "+"
        elif opcion == "2":
            resultado = a - b
            operador = "-"
        elif opcion == "3":
            resultado = a * b
            operador = "*"
        elif opcion == "4":
            if b == 0:
                raise ZeroDivisionError("Divisi√≥n por cero no permitida")
            resultado = a / b
            operador = "/"
        else:
            print("‚ùå Opci√≥n inv√°lida. Operaci√≥n cancelada.")
            return
        
        print(f"\n‚úÖ Resultado: {a} {operador} {b} = {resultado:.4f}")
    except ZeroDivisionError as e:
        print(f"‚ùå Error matem√°tico: {str(e)}")
    except Exception as e:
        print(f"‚ùå Error inesperado: {str(e)}")

def areas_geometricas():
    """Calcula √°reas y propiedades de figuras geom√©tricas con manejo de errores."""
    print("\n" + "="*40)
    print("‡πÇ‡∏õ‡∏£‡πÅ‡∏Å‡∏£‡∏ö √ÅREAS GEOM√âTRICAS")
    print("="*40)
    
    print("Figuras disponibles:")
    print("1. C√≠rculo (√°rea, di√°metro, radio)")
    print("2. Cuadrado (√°rea)")
    print("3. Tri√°ngulo (√°rea)")
    print("4. Trapecio (√°rea)")
    
    figura = input("Seleccione una figura (1-4): ").strip()
    
    try:
        if figura == "1":  # C√≠rculo
            print("\n¬øQu√© dato conoce?")
            print("1. Radio")
            print("2. Di√°metro")
            tipo_dato = input("Seleccione (1-2): ").strip()
            
            if tipo_dato == "1":
                radio = validar_numero("Ingrese el radio: ", "float", positivo=True)
                area = math.pi * radio**2
                diametro = 2 * radio
                print(f"\n‚úÖ Resultados para c√≠rculo:")
                print(f"   Radio: {radio:.4f}")
                print(f"   Di√°metro: {diametro:.4f}")
                print(f"   √Årea: {area:.4f}")
            elif tipo_dato == "2":
                diametro = validar_numero("Ingrese el di√°metro: ", "float", positivo=True)
                radio = diametro / 2
                area = math.pi * radio**2
                print(f"\n‚úÖ Resultados para c√≠rculo:")
                print(f"   Di√°metro: {diametro:.4f}")
                print(f"   Radio: {radio:.4f}")
                print(f"   √Årea: {area:.4f}")
            else:
                print("‚ùå Opci√≥n inv√°lida para c√≠rculo.")
        
        elif figura == "2":  # Cuadrado
            lado = validar_numero("Ingrese el lado del cuadrado: ", "float", positivo=True)
            area = lado**2
            print(f"\n‚úÖ √Årea del cuadrado: {area:.4f}")
        
        elif figura == "3":  # Tri√°ngulo
            base = validar_numero("Ingrese la base del tri√°ngulo: ", "float", positivo=True)
            altura = validar_numero("Ingrese la altura del tri√°ngulo: ", "float", positivo=True)
            area = (base * altura) / 2
            print(f"\n‚úÖ √Årea del tri√°ngulo: {area:.4f}")
        
        elif figura == "4":  # Trapecio
            base1 = validar_numero("Ingrese la base mayor: ", "float", positivo=True)
            base2 = validar_numero("Ingrese la base menor: ", "float", positivo=True)
            altura = validar_numero("Ingrese la altura: ", "float", positivo=True)
            area = ((base1 + base2) * altura) / 2
            print(f"\n‚úÖ √Årea del trapecio: {area:.4f}")
        
        else:
            print("‚ùå Figura no v√°lida.")
    
    except Exception as e:
        print(f"‚ùå Error en c√°lculo geom√©trico: {str(e)}")

def estadistica_basica():
    """Calcula media, mediana y moda de una serie de n√∫meros ingresados por el usuario."""
    print("\n" + "="*40)
    print("‡πÇ‡∏õ‡∏£‡πÅ‡∏Å‡∏£‡∏ö ESTAD√çSTICA B√ÅSICA")
    print("="*40)
    
    numeros = []
    print("Ingrese n√∫meros uno por uno (escriba 'fin' para terminar):")
    
    while True:
        entrada = input("N√∫mero: ").strip().lower()
        if entrada == 'fin':
            break
        try:
            numero = float(entrada)
            numeros.append(numero)
        except ValueError:
            print("‚ùå Entrada inv√°lida. Ingrese un n√∫mero o 'fin'.")
    
    if not numeros:
        print("‚ùå No se ingresaron n√∫meros. Operaci√≥n cancelada.")
        return
    
    try:
        # Media
        media = sum(numeros) / len(numeros)
        
        # Mediana
        numeros_ordenados = sorted(numeros)
        n = len(numeros_ordenados)
        if n % 2 == 0:
            mediana = (numeros_ordenados[n//2 - 1] + numeros_ordenados[n//2]) / 2
        else:
            mediana = numeros_ordenados[n//2]
        
        # Moda (maneja m√∫ltiples modas seleccionando la m√°s peque√±a)
        conteo = Counter(numeros_ordenados)
        max_frecuencia = max(conteo.values())
        modas = [num for num, freq in conteo.items() if freq == max_frecuencia]
        moda = min(modas)  # Selecciona la moda m√°s peque√±a en caso de empate
        
        print("\n‚úÖ Resultados estad√≠sticos:")
        print(f"   Media: {media:.4f}")
        print(f"   Mediana: {mediana:.4f}")
        print(f"   Moda: {moda:.4f} (frecuencia: {max_frecuencia})")
    
    except Exception as e:
        print(f"‚ùå Error en c√°lculos estad√≠sticos: {str(e)}")

def es_numero_fibonacci(n):
    """Verifica si un n√∫mero pertenece a la sucesi√≥n de Fibonacci usando propiedades matem√°ticas."""
    if n < 0:
        return False
    # Propiedad: Un n√∫mero es de Fibonacci si 5n¬≤¬±4 es un cuadrado perfecto
    def es_cuadrado_perfecto(x):
        raiz = int(math.isqrt(x))
        return raiz * raiz == x
    
    return es_cuadrado_perfecto(5*n*n + 4) or es_cuadrado_perfecto(5*n*n - 4)

def sucesion_fibonacci():
    """Genera t√©rminos de la sucesi√≥n de Fibonacci desde un n√∫mero inicial v√°lido."""
    print("\n" + "="*40)
    print("‡πÇ‡∏õ‡∏£‡πÅ‡∏Å‡∏£b SUCESI√ìN DE FIBONACCI")
    print("="*40)
    
    while True:
        inicio = validar_numero("Ingrese el n√∫mero inicial: ", "int", positivo=True)
        if es_numero_fibonacci(inicio):
            break
        print(f"‚ùå '{inicio}' no pertenece a la sucesi√≥n real de Fibonacci. Intente con otro n√∫mero.")
    
    terminos = validar_numero("¬øCu√°ntos t√©rminos desea generar? ", "int", positivo=True)
    
    # Generar sucesi√≥n real (no inventada)
    fib_sequence = []
    a, b = 0, 1
    
    # Avanzar hasta encontrar el n√∫mero inicial
    while a < inicio:
        a, b = b, a + b
    
    # Si el n√∫mero inicial es 0 o 1, ajustar inicio
    if inicio == 0:
        fib_sequence = [0]
        a, b = 0, 1
    elif inicio == 1:
        fib_sequence = [1]
        a, b = 1, 2  # Saltar el primer 1 para evitar duplicados innecesarios
    
    # Generar t√©rminos restantes
    while len(fib_sequence) < terminos:
        if a >= inicio:
            fib_sequence.append(a)
        a, b = b, a + b
    
    fib_sequence = fib_sequence[:terminos]  # Asegurar cantidad exacta de t√©rminos
    
    print(f"\n‚úÖ Sucesi√≥n de Fibonacci desde {inicio} ({terminos} t√©rminos):")
    print(" ‚Üí ".join(map(str, fib_sequence)))

def menu_principal():
    """Men√∫ interactivo principal con navegaci√≥n y manejo de errores."""
    while True:
        print("\n" + "="*50)
        print("‡πÇ‡∏õ‡∏£‡πÅ‡∏Å‡∏£b CALCULADORA MULTIFUNCIONAL")
        print("="*50)
        print("1. Operaciones B√°sicas (+, -, *, /)")
        print("2. C√°lculo de √Åreas Geom√©tricas")
        print("3. Estad√≠stica B√°sica (Media, Mediana, Moda)")
        print("4. Sucesi√≥n de Fibonacci")
        print("5. Salir")
        
        opcion = input("\nSeleccione una opci√≥n (1-5): ").strip()
        
        if opcion == "1":
            operaciones_basicas()
        elif opcion == "2":
            areas_geometricas()
        elif opcion == "3":
            estadistica_basica()
        elif opcion == "4":
            sucesion_fibonacci()
        elif opcion == "5":
            print("\n¬°Gracias por usar la calculadora! üëã")
            print("="*50)
            break
        else:
            print("‚ùå Opci√≥n inv√°lida. Por favor seleccione un n√∫mero entre 1 y 5.")

if __name__ == "__main__":
    menu_principal()